<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyPage</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://figureai.github.io/"/>
  <updated>2020-05-09T09:05:11.028Z</updated>
  <id>http://figureai.github.io/</id>
  
  <author>
    <name>Figure Ai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gitignore忽略规则简单说明</title>
    <link href="http://figureai.github.io/2020/05/09/gitignore%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99/"/>
    <id>http://figureai.github.io/2020/05/09/gitignore%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99/</id>
    <published>2020-05-09T09:05:04.000Z</published>
    <updated>2020-05-09T09:05:11.028Z</updated>
    
    <content type="html"><![CDATA[<p>.gitignore忽略规则简单说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#               表示此为注释,将被Git忽略</span><br><span class="line">*.a             表示忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a          表示但lib.a除外</span><br><span class="line">&#x2F;TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir&#x2F;TODO</span><br><span class="line">build&#x2F;          表示忽略 build&#x2F;目录下的所有文件，过滤整个build文件夹；</span><br><span class="line">doc&#x2F;*.txt       表示会忽略doc&#x2F;notes.txt但不包括 doc&#x2F;server&#x2F;arch.txt</span><br><span class="line"> </span><br><span class="line">bin&#x2F;:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">&#x2F;bin:           表示忽略根目录下的bin文件</span><br><span class="line">&#x2F;*.c:           表示忽略cat.c，不忽略 build&#x2F;cat.c</span><br><span class="line">debug&#x2F;*.obj:    表示忽略debug&#x2F;io.obj，不忽略 debug&#x2F;common&#x2F;io.obj和tools&#x2F;debug&#x2F;io.obj</span><br><span class="line">**&#x2F;foo:         表示忽略&#x2F;foo,a&#x2F;foo,a&#x2F;b&#x2F;foo等</span><br><span class="line">a&#x2F;**&#x2F;b:         表示忽略a&#x2F;b, a&#x2F;x&#x2F;b,a&#x2F;x&#x2F;y&#x2F;b等</span><br><span class="line">!&#x2F;bin&#x2F;run.sh    表示不忽略bin目录下的run.sh文件</span><br><span class="line">*.log:          表示忽略所有 .log 文件</span><br><span class="line">config.php:     表示忽略当前路径的 config.php 文件</span><br><span class="line"> </span><br><span class="line">&#x2F;mtk&#x2F;           表示过滤整个文件夹</span><br><span class="line">*.zip           表示过滤所有.zip文件</span><br><span class="line">&#x2F;mtk&#x2F;do.c       表示过滤某个具体文件</span><br><span class="line"> </span><br><span class="line">被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</span><br><span class="line"> </span><br><span class="line">需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：</span><br><span class="line">!*.zip</span><br><span class="line">!&#x2F;mtk&#x2F;one.txt</span><br><span class="line"> </span><br><span class="line">唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？</span><br><span class="line">想象一个场景：假如我们只需要管理&#x2F;mtk&#x2F;目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：</span><br><span class="line">&#x2F;mtk&#x2F;*</span><br><span class="line">!&#x2F;mtk&#x2F;one.txt</span><br><span class="line"> </span><br><span class="line">假设我们只有过滤规则，而没有添加规则，那么我们就需要把&#x2F;mtk&#x2F;目录下除了one.txt以外的所有文件都写出来！</span><br><span class="line">注意上面的&#x2F;mtk&#x2F;*不能写为&#x2F;mtk&#x2F;，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</span><br><span class="line"> </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">还有一些规则如下：</span><br><span class="line">fd1&#x2F;*</span><br><span class="line">说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 &#x2F;fd1&#x2F; 目录，还是某个子目录 &#x2F;child&#x2F;fd1&#x2F; 目录，都会被忽略；</span><br><span class="line"> </span><br><span class="line">&#x2F;fd1&#x2F;*</span><br><span class="line">说明：忽略根目录下的 &#x2F;fd1&#x2F; 目录的全部内容；</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line">!.gitignore</span><br><span class="line">!&#x2F;fw&#x2F; </span><br><span class="line">&#x2F;fw&#x2F;*</span><br><span class="line">!&#x2F;fw&#x2F;bin&#x2F;</span><br><span class="line">!&#x2F;fw&#x2F;sf&#x2F;</span><br><span class="line">说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 &#x2F;fw&#x2F;bin&#x2F; 和 &#x2F;fw&#x2F;sf&#x2F; 目录；注意要先对bin&#x2F;的父目录使用!规则，使其不被排除。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;.gitignore忽略规则简单说明&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>redux、react-redux、redux-thunk结合使用</title>
    <link href="http://figureai.github.io/2020/05/08/redux%E3%80%81react-redux%E3%80%81redux-thunk%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>http://figureai.github.io/2020/05/08/redux%E3%80%81react-redux%E3%80%81redux-thunk%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</id>
    <published>2020-05-08T07:27:09.000Z</published>
    <updated>2020-05-09T09:03:43.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul><li><p>redux</p><blockquote><p>redux是一个统一数据流状态管理的js库，本身使用与react、或者vue框架等无关。</p></blockquote></li><li><p>react-redux</p><blockquote><p>将redux应用到react上的库。</p></blockquote></li><li><p>redux-thunk</p><blockquote><p>redux-thunk，redux 的一个中间件，可以实现在使用redux时发异步action。</p></blockquote></li></ul><h2 id="什么时候需要使用redux"><a href="#什么时候需要使用redux" class="headerlink" title="什么时候需要使用redux"></a>什么时候需要使用redux</h2><blockquote><p>当你的应用有许多动态数据需要在不同的页面共享时，比如说当用户修改了账户昵称之后所有的相关页面都要更新昵称，面对这样的需求，如果不使用redux，则需要通过发送通知或者数据传递的方式来解决，而使用redux则可以大大简化操作。</p></blockquote><h2 id="redux-核心概念"><a href="#redux-核心概念" class="headerlink" title="redux 核心概念"></a>redux 核心概念</h2><ul><li>Store<blockquote><p>Store 是 redux存放数据的地方，每个应用有且只有一个store，比如说修改昵称那个例子，昵称字段（假设为nickName）就需要存放在store中，其他用到的页面也是从store获取，当store中的nickName更新时，所有用到的页面或组件就会自动更新。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore&#125; from &#39;redux&#39;</span><br><span class="line">import rootReducers from &#39;.&#x2F;reducers&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个storage </span><br><span class="line">const store &#x3D; createStore(</span><br><span class="line">    rootReducers,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default store</span><br></pre></td></tr></table></figure><ul><li><p>Reducer</p><blockquote><p>reducer 是用来计算组成state的纯函数，每个reducer都会接收一个旧的state和action，并且返回一个新的state，需要注意的是，reducer是一个纯函数，固定的输入会得到固定输出，因此要避免在reducer中修改传入的参数，或者使用<code>Date.now()</code>、<code>Math.random()</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; reducer 接收旧的state和新的action，返回新的state</span><br><span class="line">const counterReducer &#x3D; function(state&#x3D;&#123;count:1&#125;, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &#39;COUNT_ADD&#39;:</span><br><span class="line">            return &#123;...state, count: state.count+1&#125;</span><br><span class="line"></span><br><span class="line">        case &#39;COUNT_REDUCE&#39;:</span><br><span class="line">            return &#123;...state, count: state.count-1&#125;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default counterReducer</span><br></pre></td></tr></table></figure></li><li><p>Action</p><blockquote><p>如果需要修改state中的数据，就需要通过分发action的方式来修改<code>(Store.dispatch(action))</code>，action包含type和payload字段，type定义了action的类型，payload则是此次action携带的数据。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; action包含type和payload属性，reducer拿到action可以通过type进行相应的逻辑处理</span><br><span class="line">const addAction &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: &#39;COUNTER_ADD&#39;,</span><br><span class="line">        payload: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reduceAction &#x3D; () &#x3D;&gt;&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: &#39;COUNTER_REDUCE&#39;,</span><br><span class="line">        payload: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    addAction,</span><br><span class="line">    reduceAction,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="redux-设计原则"><a href="#redux-设计原则" class="headerlink" title="redux 设计原则"></a>redux 设计原则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 单一数据源：所有状态都保存在单一的store中</span><br><span class="line">2. state是只读的: 不能直接对store进行修改,只能通过新的store替换旧的store</span><br><span class="line">3. 使用纯函数来执行修改:reducer是只读的</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gemavjob2pg31400u0npe.gif" alt="redux数据流流程图"></p><h2 id="react-redux-的作用"><a href="#react-redux-的作用" class="headerlink" title="react-redux 的作用"></a>react-redux 的作用</h2><blockquote><p>react-redux 能将redux那套逻辑应用在react框架上。</p></blockquote><h3 id="react-redux-核心-api"><a href="#react-redux-核心-api" class="headerlink" title="react-redux 核心 api"></a>react-redux 核心 api</h3><ul><li>Provider<blockquote><p>通过Proveder可以把redux和react建立连接，将store传递到react项目中</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#123;Provider&#125; from &#39;react-redux&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &#x2F;&#x2F; 通过Proveder把redux和react建立连接，将store传递到react项目中</span><br><span class="line">    &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">        &lt;App &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;, </span><br><span class="line">    document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><ul><li>connect</li></ul><blockquote><p>使用到store中数据的组件，需要先用connect修饰一遍</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 指定 的 store 合并到 props 传给组件</span><br><span class="line">const mapStateToProps &#x3D; (state, ownProps) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        post: state.postReducer</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将 指定的 dispatch 合并到 props 传给组件</span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch, ownProps) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        test: ()&#x3D;&gt;&#123;</span><br><span class="line">            dispatch(loadPostsAction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HomeScreen经过connect 包装就可以使用 mapStateToProps，mapDispatchToProps 传递过去的数据了</span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(HomeScreen)</span><br></pre></td></tr></table></figure><h2 id="redux-thunk-的作用"><a href="#redux-thunk-的作用" class="headerlink" title="redux-thunk 的作用"></a>redux-thunk 的作用</h2><blockquote><p>redux-thunk 是 redux的一个中间件，可以实现发异步action，因为有一些action携带的数据可能是由后台获取的，这时候就需要redux-thunk的协助了。</p></blockquote><ul><li><p>使用中间件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore, compose, applyMiddleware&#125; from &#39;redux&#39;</span><br><span class="line">import thunk from &#39;redux-thunk&#39;</span><br><span class="line">import rootReducers from &#39;.&#x2F;reducers&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个storage storage 接收一个参数，reducer</span><br><span class="line">const store &#x3D; createStore(</span><br><span class="line">    rootReducers,</span><br><span class="line">    compose(</span><br><span class="line">        applyMiddleware(...[thunk,]),</span><br><span class="line">        window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__(),</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default store</span><br></pre></td></tr></table></figure></li><li><p>发送异步action</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123;getPosts&#125; from &#39;..&#x2F;services&#x2F;post_api&#39;</span><br><span class="line"></span><br><span class="line">const loadPostsAction &#x3D; async (dispatch)&#x3D;&gt;&#123;</span><br><span class="line">    const &#123;data&#125; &#x3D; await getPosts()</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">        type: &#39;LOAD_POSTS&#39;,</span><br><span class="line">        payload: data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    loadPostsAction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>本文demo：<a href="https://github.com/figureai/StudyBase/tree/master/redux.base" target="_blank" rel="noopener">redux使用示例</a></p></blockquote><blockquote><p>参考文章：<br>    <a href="https://juejin.im/post/5bac26ad6fb9a05d353c8040" target="_blank" rel="noopener">Redux for react native 指南</a>，<br>    <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html#comment-text" target="_blank" rel="noopener">Redux 入门教程（一）：基本用法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;redux&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redux是一个统一数据流状态管理的js库，本身使用与
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ReactNative | bug 合集</title>
    <link href="http://figureai.github.io/2020/03/29/ReactNative%20|%20bug%20%E5%90%88%E9%9B%86/"/>
    <id>http://figureai.github.io/2020/03/29/ReactNative%20|%20bug%20%E5%90%88%E9%9B%86/</id>
    <published>2020-03-29T13:27:39.000Z</published>
    <updated>2020-05-09T09:10:19.992Z</updated>
    
    <content type="html"><![CDATA[<ol><li>iOS xcode11 以上运行报错 <code>Unknown argument type ‘attribute’ in method -[RCTAppState getCurrentAppState:error:]. Extend RCTConvert to support this type.</code></li></ol><blockquote><p>// 解决方案一： 升级 RN 版本到 0.59.9 以上<br>// 解决方案二： [project_folder]/node_modules/react-native/React/Base/RCTModuleMethod.mm 文件 第 91 行 return RCTReadString(input, “<strong>attribute</strong>((unused))”) || 后面添加<br>RCTReadString(input, “<strong>attribute</strong>((<strong>unused</strong>))”) || 这一行</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;iOS xcode11 以上运行报错 &lt;code&gt;Unknown argument type ‘attribute’ in method -[RCTAppState getCurrentAppState:error:]. Extend RCTConvert to
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS | bug 合集</title>
    <link href="http://figureai.github.io/2020/03/29/iOS%20|%20bug%20%E5%90%88%E9%9B%86/"/>
    <id>http://figureai.github.io/2020/03/29/iOS%20|%20bug%20%E5%90%88%E9%9B%86/</id>
    <published>2020-03-29T05:27:20.000Z</published>
    <updated>2020-03-29T05:27:32.936Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="iOS" scheme="http://figureai.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Android | bug 合集</title>
    <link href="http://figureai.github.io/2020/03/26/Android%20|%20bug%20%E5%90%88%E9%9B%86/"/>
    <id>http://figureai.github.io/2020/03/26/Android%20|%20bug%20%E5%90%88%E9%9B%86/</id>
    <published>2020-03-26T23:11:28.000Z</published>
    <updated>2020-05-09T09:10:19.992Z</updated>
    
    <content type="html"><![CDATA[<ol><li>打包时报错 <code>You should manually set the same version via DependencyResolution</code><blockquote><p>报错原因： 项目添加的第三方库依赖的版本不一致</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 解决方案一 ： 升级Android X</span><br><span class="line">&#x2F;&#x2F; 解决方案二 ： 项目级 gradle 文件下添加以下配置</span><br><span class="line">subprojects &#123;</span><br><span class="line">    configurations.all &#123;</span><br><span class="line">        resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">            def requested &#x3D; details.requested</span><br><span class="line">            if (requested.group &#x3D;&#x3D; &#39;com.android.support&#39;) &#123;</span><br><span class="line">                if (!requested.name.startsWith(&quot;multidex&quot;)) &#123;</span><br><span class="line">                    details.useVersion &#39;25.4.0&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>打包时报错 <code>Execution failed for task &#39;:app:lintVitalRelease&#39;.</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;build.gradle</span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 增加</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        checkReleaseBuilds false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;打包时报错 &lt;code&gt;You should manually set the same version via DependencyResolution&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;报错原因： 项目添加的第三方库依赖的版本不一致&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="Android" scheme="http://figureai.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://figureai.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>js | 算法题</title>
    <link href="http://figureai.github.io/2020/03/24/js%20|%20%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://figureai.github.io/2020/03/24/js%20|%20%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2020-03-24T15:46:10.000Z</published>
    <updated>2020-05-09T09:10:19.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><blockquote><p>本文示例代码使用 js 编写=</p></blockquote><p><strong>冒泡排序</strong></p><blockquote><p>比较相邻的两个元素，如果后一个比前一个大，交换位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [1,2, 0,421,2,33,4,344]</span><br><span class="line">for(let j &#x3D; 0; j &lt; array.length; j++) &#123;</span><br><span class="line">    for(let k &#x3D; 0; k &lt; array.length; k++) &#123;</span><br><span class="line">        let a &#x3D; array[j]</span><br><span class="line">        let b &#x3D; array[k]</span><br><span class="line">        if(b &lt; a) &#123;</span><br><span class="line">            array[j] &#x3D; b</span><br><span class="line">            array[k] &#x3D; a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(array)</span><br></pre></td></tr></table></figure><p><strong>数组去重</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [1,2,3,22,3,2,3,4]</span><br><span class="line"></span><br><span class="line">function deleteRepat(array) &#123;</span><br><span class="line">    let dict &#x3D; &#123;&#125;</span><br><span class="line">    for(let index &#x3D; 0; index &lt; array.length; index++) &#123;</span><br><span class="line">        dict[array[index]] &#x3D; index</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.keys(dict)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Object.keys(dict))</span><br></pre></td></tr></table></figure><p><strong>字符串转驼峰</strong></p><blockquote><p>border-bottom-color —-&gt; borderBottomColor</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function topUper(str) &#123;</span><br><span class="line">    let result &#x3D; &#39;&#39;</span><br><span class="line">    const splitArray &#x3D; str.split(&#39;-&#39;)</span><br><span class="line">    for(let index &#x3D; 0; index &lt; splitArray.length; index++) &#123;</span><br><span class="line">        let tempStr &#x3D; splitArray[index]</span><br><span class="line">        if(index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            result &#x3D; tempStr.toLowerCase()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result +&#x3D; tempStr.charAt(0).toUpperCase() + tempStr.substring(1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const str &#x3D; &quot;BBB-bottom-color&quot;</span><br><span class="line">console.log(topUper(str))</span><br></pre></td></tr></table></figure><p><strong>查找字符串中出现次数最多的字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function getMaxCount(str) &#123;</span><br><span class="line">    const splitArray &#x3D; str.split(&#39;&#39;)</span><br><span class="line">    let result &#x3D; &#123;&#125;</span><br><span class="line">    splitArray.forEach(target &#x3D;&gt; &#123;</span><br><span class="line">        if(result[target] !&#x3D; undefined) &#123;</span><br><span class="line">            result[target] +&#x3D; 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result[target] &#x3D; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(result)</span><br><span class="line">    let maxKey &#x3D; Object.keys(result)[0]</span><br><span class="line">    Object.keys(result).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">        if(result[key] &gt; result[maxKey]) &#123;</span><br><span class="line">            maxKey &#x3D; key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return maxKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getMaxCount(&#39;aaaaabbeeeeeeeeeee&#39;))</span><br></pre></td></tr></table></figure><p><strong>编写一个产生在 m、n 之间的随机整数的方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注&quot;&gt;&lt;a href=&quot;#注&quot; class=&quot;headerlink&quot; title=&quot;注&quot;&gt;&lt;/a&gt;注&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文示例代码使用 js 编写=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="算法" scheme="http://figureai.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="js" scheme="http://figureai.github.io/tags/js/"/>
    
      <category term="算法" scheme="http://figureai.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js | 有趣的笔试题</title>
    <link href="http://figureai.github.io/2020/03/24/js%20|%20%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://figureai.github.io/2020/03/24/js%20|%20%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-24T14:27:41.000Z</published>
    <updated>2020-05-09T09:10:19.992Z</updated>
    
    <content type="html"><![CDATA[<p><strong>请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; &quot;http:&#x2F;&#x2F;www.taobao.com&#x2F;index.php?key0&#x3D;0&amp;key1&#x3D;1&amp;key2&#x3D;2.....&quot;</span><br><span class="line">var obj &#x3D; parseQueryString(url);</span><br><span class="line">console.log(obj.key0)</span><br></pre></td></tr></table></figure><p>答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function parseQueryString(url) &#123;</span><br><span class="line">    const result &#x3D; url.split(&#39;?&#39;)</span><br><span class="line">    if(result.length &lt; 2) &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const queryStr &#x3D; result[1]</span><br><span class="line">    const queryArray &#x3D; queryStr.split(&#39;&amp;&#39;)</span><br><span class="line">    let dict &#x3D; &#123;&#125;</span><br><span class="line">    queryArray.forEach(element &#x3D;&gt; &#123;</span><br><span class="line">        const keyValues &#x3D; element.split(&#39;&#x3D;&#39;)</span><br><span class="line">        dict[keyValues[0]] &#x3D; keyValues[1]</span><br><span class="line">    &#125;);</span><br><span class="line">    return dict</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尝试实现注释部分的 Javascript 代码，可在其他任何地方添加更多代码（如不能实现，说明一下不能实现的原因）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Obj &#x3D; function(msg)&#123;</span><br><span class="line">    this.msg &#x3D; msg;</span><br><span class="line">    this.shout &#x3D; function()&#123;</span><br><span class="line">        alert(this.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    this.waitAndShout &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;隔五秒钟后执行上面的shout方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var Obj &#x3D; function(msg)&#123;</span><br><span class="line">    this.msg &#x3D; msg;</span><br><span class="line">    this.shout &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F; alert(this.msg);</span><br><span class="line">        console.log(this.msg)</span><br><span class="line">    &#125;</span><br><span class="line">    this.waitAndShout &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;隔五秒钟后执行上面的shout方法</span><br><span class="line">        setTimeout(()&#x3D;&gt;this.shout(), 5000)</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Obj(&#39;hello&#39;)</span><br><span class="line">obj.waitAndShout()</span><br></pre></td></tr></table></figure><p><strong>请给 JavaScript 的 String 原生对象添加一个名为 trim 的原型方法，用于截取空白字符。要求：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot; taobao&quot;.trim());     &#x2F;&#x2F; 输出 &quot;taobao&quot;</span><br><span class="line">console.log(&quot; taobao &quot;.trim());    &#x2F;&#x2F; 输出 &quot;taobao&quot;</span><br></pre></td></tr></table></figure><p>答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.trim &#x3D; function() &#123;</span><br><span class="line">    return this.split(&#39; &#39;).join(&#39;&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请说明下面各种情况的执行结果，并注明产生对应结果的理由。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">element.onclick &#x3D; doSomething &#x2F;&#x2F; 1. 点击element元素后。 </span><br><span class="line">element.onclick &#x3D; function() &#123;doSomething()&#125; &#x2F;&#x2F; 2. 点击element元素后。 </span><br><span class="line">doSomething()   &#x2F;&#x2F; 3.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 通过函数赋值方式，this直接指向element对象</span><br><span class="line">2. this 是写在doSomething()里边的，而this的指向又跟谁调用它有关，如果没有对象调用它，就是指向window</span><br><span class="line">3. this指向window</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
    
      <category term="js" scheme="http://figureai.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js | 的this指向问题</title>
    <link href="http://figureai.github.io/2020/03/23/js%20|%20%E5%85%B3%E4%BA%8Ejs%E7%9A%84this%E6%8C%87%E9%92%88/"/>
    <id>http://figureai.github.io/2020/03/23/js%20|%20%E5%85%B3%E4%BA%8Ejs%E7%9A%84this%E6%8C%87%E9%92%88/</id>
    <published>2020-03-23T11:17:10.000Z</published>
    <updated>2020-05-09T09:10:19.992Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="关于-js-的-this-指向问题"><a href="#关于-js-的-this-指向问题" class="headerlink" title="关于 js 的 this 指向问题"></a>关于 js 的 this 指向问题</h1><blockquote><p>一直以来对于 js 的 this 指针这一块理解都是比较模糊，也有查阅过相关资料，但是时间一长又会忘记，所以这篇文章单独记录一下 this 指针的指向问题，一方面加深记忆，一方面也方便自己查阅</p></blockquote><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p><strong>谁调用就指向谁，没人调用就指向window，简单来说函数的 this 和谁调用它有关。如果没有对象调用它，那么 this 就是指向 window（es5 环境下）</strong>函数的调用方式决定了 this 的指向，所以理解 this 的指向问题，最简单的方法就是通过分析 js 几种函数的调用模式。js 函数的调用模式有：<strong>函数调用模式</strong>、<strong>方法调用模式</strong>、<strong>构造函数调用模式</strong>、<strong>apply 和 call 调用模式</strong>、<strong>以及箭头函数</strong></p></blockquote><h2 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h2><blockquote><p>函数被直接调用时，其实是作为属性挂载在<strong>全局对象下</strong>，所以这种模式<strong>在浏览器环境</strong>下 this 自然指向<strong>window 对象</strong></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd42s9x2hrj30ht03kdg1.jpg" alt="函数调用模式下的this指向"></p><h2 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h2><blockquote><p>当函数被保存为一个对象的属性，通过对象 <strong>.</strong>或者 <strong>[]</strong>调用时，称为方法调用模式，这种情况 this 被绑定在调用的对象上。</p></blockquote><ol><li>一层嵌套</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">const dict &#x3D; &#123;</span><br><span class="line">    name: &#39;dict&#39;,</span><br><span class="line">    test: function() &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印 dict</span><br><span class="line">dict.test()</span><br></pre></td></tr></table></figure><ol start="2"><li>对象多重嵌套<blockquote><p>这种情况下，不管是嵌套多少层，this 都会指向到调用他的对象上</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const first &#x3D; &#123;</span><br><span class="line">    name: &#39;first&#39;,</span><br><span class="line">    second: &#123;</span><br><span class="line">        name: &#39;second&#39;,</span><br><span class="line">        test: function() &#123;</span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里因为调用test方法是second对象，所以指向对象是second</span><br><span class="line">first.second.test()</span><br></pre></td></tr></table></figure><ol start="3"><li>方法被赋值为一个新对象<blockquote><p>这种情况下相当于回到函数调用模式</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const first &#x3D; &#123;</span><br><span class="line">    name: &#39;first&#39;,</span><br><span class="line">    second: &#123;</span><br><span class="line">        name: &#39;second&#39;,</span><br><span class="line">        test: function() &#123;</span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name &#x3D; &#39;a&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印 a，这里因为a是挂载在全局对象下，所以this自然指向全局对象</span><br><span class="line">const a &#x3D; first.second.test</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><h2 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h2><blockquote><p>如果函数在被 new 关键字创建为一个新的实例对象，那么这个函数就成为此对象的构造函数，如果<strong>构造函数不返回对象，this 就指向这个实例。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数不返回对象，this指向实例</span><br><span class="line">function Fn() &#123;</span><br><span class="line">    this.name &#x3D; &#39;hello&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; new Fn()</span><br><span class="line"></span><br><span class="line">console.log(a.name)</span><br></pre></td></tr></table></figure><h2 id="call-和-apply-调用模式"><a href="#call-和-apply-调用模式" class="headerlink" title="call 和 apply 调用模式"></a>call 和 apply 调用模式</h2><blockquote><p>js 中的函数也是对象，所有函数都有两个方法 <strong>call 和 apply</strong>，这两个方法可以让我们构建一个参数数组传递给调用函数，同时也允许我们改变 this 的指向</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &#39;window&#39;</span><br><span class="line"></span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; &#123;</span><br><span class="line">    name: &#39;objA&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName.apply(a)    &#x2F;&#x2F; objA</span><br><span class="line">getName.call(a)     &#x2F;&#x2F; objA</span><br><span class="line">getName.apply()     &#x2F;&#x2F; window</span><br><span class="line">getName.call()      &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>以下代码中是用 es6 的 class 定义的一个方法，这段代码在 es5 的环境下理论上应该是输出 ‘window’，但是实际运行 this 的指向会变成 undefined，猜测应该是 es6 的 class 关键字做了优化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">name &#x3D; &#39;window&#39;</span><br><span class="line">class A &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const a &#x3D; new A(&#39;objA&#39;)</span><br><span class="line">const test &#x3D; a.getName</span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es5</span><br><span class="line">name &#x3D; &#39;window&#39;</span><br><span class="line">function A(name) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">const a &#x3D; new A(&#39;objA&#39;)</span><br><span class="line">const test &#x3D; a.getName</span><br><span class="line">&#x2F;&#x2F; 打印window</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;关于-js-的-this-指向问题&quot;&gt;&lt;a href=&quot;#关于-js-的-this-指向问题&quot; class=&quot;headerlink&quot; title=&quot;关于 js 的 this 指向问题&quot;&gt;&lt;/a&gt;关于 js 的 this 指向问题&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://figureai.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://figureai.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>提高github搜索精确度</title>
    <link href="http://figureai.github.io/2020/03/21/GitHub%20|%20%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F/"/>
    <id>http://figureai.github.io/2020/03/21/GitHub%20|%20%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-21T00:24:58.000Z</published>
    <updated>2020-03-29T05:26:23.904Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; xxx 代表搜索内容</span><br><span class="line">&#x2F;&#x2F; 在项目名进行精确搜索</span><br><span class="line">in:name xxx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 搜索名字包含xxx，stars数量大于3000的项目</span><br><span class="line">in:name xxx stars:&gt;3000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 搜索名字包含xxx，forks大于100的项目</span><br><span class="line">in:name xxx forks:&gt;100</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 搜索readme包含xxx的项目</span><br><span class="line">in:readme xxx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 搜索描述包含xxx的项目</span><br><span class="line">in:description xxx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 搜索xxx语言编写，名字包含xxx的项目</span><br><span class="line">in:name xxx language:xxx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 搜索最后一次更细时间在2019年9月3日之后的项目</span><br><span class="line">xxx pushed:&gt;2019-09-03</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="高效操作" scheme="http://figureai.github.io/categories/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="github" scheme="http://figureai.github.io/tags/github/"/>
    
      <category term="效率" scheme="http://figureai.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>js | 正则表达式的基本使用</title>
    <link href="http://figureai.github.io/2020/03/20/js%20|%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://figureai.github.io/2020/03/20/js%20|%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-20T14:53:45.000Z</published>
    <updated>2020-05-09T09:10:19.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h1><blockquote><p>本文整理了一些常用的正则表达式匹配符，使用的示例代码为 js 编写，参考文章 <a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">正则表达式手册</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expression" target="_blank" rel="noopener">MDN 文档-正则表达式</a></p></blockquote><h2 id="正则表达式规则类型"><a href="#正则表达式规则类型" class="headerlink" title="正则表达式规则类型"></a>正则表达式规则类型</h2><ul><li><p>断言</p><blockquote><p>表示一个匹配在某些条件发生</p></blockquote></li><li><p>边界</p><blockquote><p>表示行和单词的的开始和结尾，如：<code>^ 匹配起始位置</code> ，<code>$ 匹配结束位置</code></p></blockquote></li><li><p>字符类别</p><blockquote><p>区分不同类型的字符，如： <code>\D 匹配一个非数字字符</code>，<code>\d 匹配一个数字字符</code></p></blockquote></li><li><p>组合范围</p><blockquote><p>表示表达式的分组和范围，如: <code>[a-e0-4] 匹配a-e之间的字符以及0-4的数字</code></p></blockquote></li><li><p>量词</p><blockquote><p>表示匹配的字符或表达式的数量， 如： <code>a{3,4} 匹配3个或4个字母a的字符</code></p></blockquote></li><li><p>unicode 属性转义</p><blockquote><p>基于 unicode 字符属性区分字符</p></blockquote></li></ul><h2 id="常用的匹配规则"><a href="#常用的匹配规则" class="headerlink" title="常用的匹配规则"></a>常用的匹配规则</h2><blockquote><p>以下列的是常用匹配规则，完整的匹配规则可参考：<a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">正则表达式手册</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\S     : 匹配任意非空字符</span><br><span class="line">.      : 匹配 \n 之外的任何字符</span><br><span class="line">\D     : 匹配一个非数字字符，等价于[^0-9]</span><br><span class="line">\d     : 匹配个数字字符，等价于[0-9]</span><br><span class="line">[0-9]  : 匹配一个数字字符</span><br><span class="line">^      : 限定字符串的起始字符， 例如  ^a 限定匹配的字符串必须以 a 开头</span><br><span class="line">$      : 限定字符串的结束字符，例如 b$ 字符串必须以b结束</span><br><span class="line">\w      : 匹配包括下划线的任何单词或数字，等价于[A-Za-z0-9_]</span><br><span class="line">&#123;&#125;      : 匹配指定次数，eg: a&#123;3,6&#125;，最低匹配三个字符a，最高匹配6个字符a</span><br><span class="line">()      : 优先匹配括号中的内容</span><br><span class="line">+       : 至少匹配一次，等价于&#123;1,&#125;</span><br></pre></td></tr></table></figure><h2 id="全局匹配模式"><a href="#全局匹配模式" class="headerlink" title="全局匹配模式"></a>全局匹配模式</h2><blockquote><p>全局匹配模式即在匹配到第一个字符串后，会继续往后检索，直到检索完所有内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const str &#x3D; &#39;123bb456bb789&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出 [ &#39;bb&#39;, &#39;bb&#39; ]</span><br><span class="line">console.log(str.match(&#x2F;bb&#x2F;g))</span><br><span class="line"></span><br><span class="line">const reg &#x3D; new RegExp(&quot;bb&quot;,&quot;g&quot;)</span><br><span class="line">&#x2F;&#x2F; 输出 [ &#39;bb&#39;, index: 3, input: &#39;123bb4567bb89&#39;, groups: undefined ]</span><br><span class="line">console.log(reg.exec(str))</span><br></pre></td></tr></table></figure><h2 id="js-字符串支持正则表达式的方法"><a href="#js-字符串支持正则表达式的方法" class="headerlink" title="js 字符串支持正则表达式的方法"></a>js 字符串支持正则表达式的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const str &#x3D; &#39;123bb456d789&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; search(reg): 检索与reg相匹配的值</span><br><span class="line">&#x2F;&#x2F; 输出： 3</span><br><span class="line">console.log(str.search(&#x2F;b&#123;2&#125;&#x2F;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; match(reg): 找到一个或多个reg匹配的值</span><br><span class="line">&#x2F;&#x2F; 输出： [ &#39;456&#39;, index: 5, input: &#39;123bb456d789&#39;, groups: undefined ]</span><br><span class="line">console.log(str.match(&#x2F;[4-6]&#123;3&#125;&#x2F;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; replace(reg, str): 替换与reg匹配的值为str的内容</span><br><span class="line">&#x2F;&#x2F; 输出： 123bb4561119</span><br><span class="line">console.log(str.replace(&#x2F;d[7-8]&#123;2&#125;&#x2F;, &#39;111&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; split(reg, number): 把字符依照reg匹配规则分割，并且返回一个number长度的数组</span><br><span class="line">&#x2F;&#x2F; 输出： [ &#39;123bb&#39;, &#39;d789&#39; ]</span><br><span class="line">console.log(str.split(&#x2F;456&#x2F;, 2))</span><br></pre></td></tr></table></figure><h2 id="js-RegExp-对象"><a href="#js-RegExp-对象" class="headerlink" title="js RegExp 对象"></a>js RegExp 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">complie: 编译正则表达式。</span><br><span class="line">exec: 检索字符串中指定的值。返回找到的值，并确定其位置。</span><br><span class="line">test: 检索字符串中指定的值。返回 true 或 false。</span><br></pre></td></tr></table></figure><h2 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取网络链接中的某个参数值</span><br><span class="line">&#x2F;&#x2F; gcGetUrlParam（url,params） &#123;</span><br><span class="line">&#x2F;&#x2F;     var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + params + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">&#x2F;&#x2F;     var result &#x3D; url.search.substr(1).match(reg);</span><br><span class="line">&#x2F;&#x2F;     if (result &amp;&amp; result[2]) &#123;</span><br><span class="line">&#x2F;&#x2F;         return result[2];</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F;     return false;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 裁剪xx到xx之间的任意内容</span><br><span class="line">&#x2F;&#x2F; let url &#x3D; https:&#x2F;&#x2F;www.v.qq.com&#x2F;?vid&#x3D;adfadsfds2243&amp;test&#x3D;true</span><br><span class="line">&#x2F;&#x2F; let reg &#x3D; &#x2F;vid&#x3D;(.*?)&amp;&#x2F;</span><br><span class="line">&#x2F;&#x2F; let vid &#x3D; url.match(reg)[1]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 验证手机号码正则</span><br><span class="line">&#x2F;&#x2F; let reg &#x3D; &#x2F;^1([3-8])(\d&#123;9&#125;)$&#x2F;</span><br><span class="line">&#x2F;&#x2F; let test &#x3D; &#39;13160694978&#39;</span><br><span class="line">&#x2F;&#x2F; let a &#x3D; reg.exec(test)</span><br><span class="line">&#x2F;&#x2F; console.log(a)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 验证邮箱的正则</span><br><span class="line">&#x2F;&#x2F; let reg &#x3D; &#x2F;^((\S|_|-)&#123;2,10&#125;)@(\S&#123;2,6&#125;)(.com)$&#x2F;</span><br><span class="line">&#x2F;&#x2F; let test &#x3D; &#39;some_one@gmail.com&#39;</span><br><span class="line">&#x2F;&#x2F; let a &#x3D; reg.exec(test)</span><br><span class="line">&#x2F;&#x2F; console.log(a)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配任意重复字符</span><br><span class="line">&#x2F;&#x2F; var s &#x3D; &#39;aaabccc11fdsaa&#39;;</span><br><span class="line">&#x2F;&#x2F; var reg &#x3D; &#x2F;(.)\1+&#x2F;g;</span><br><span class="line">&#x2F;&#x2F; console.log(s.match(reg)); &#x2F;&#x2F;[&quot;aaa&quot;, &quot;ccc&quot;, &quot;11&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式的使用&quot;&gt;&lt;a href=&quot;#正则表达式的使用&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的使用&quot;&gt;&lt;/a&gt;正则表达式的使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文整理了一些常用的正则表达式匹配符，使用的示例代码为 js 编写
      
    
    </summary>
    
    
      <category term="编程通用" scheme="http://figureai.github.io/categories/%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8/"/>
    
    
      <category term="基础" scheme="http://figureai.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
