{"meta":{"title":"MyPage","subtitle":"","description":"","author":"Figure Ai","url":"http://figureai.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-23T03:58:59.256Z","updated":"2020-03-20T09:51:27.000Z","comments":false,"path":"/404.html","permalink":"http://figureai.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-23T03:58:59.262Z","updated":"2020-03-20T11:09:56.000Z","comments":false,"path":"about/index.html","permalink":"http://figureai.github.io/about/index.html","excerpt":"","text":"我热爱的不是编程，我热爱的只是工作"},{"title":"书单","date":"2020-03-23T03:58:59.263Z","updated":"2020-03-20T09:51:17.000Z","comments":false,"path":"books/index.html","permalink":"http://figureai.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-23T03:58:59.264Z","updated":"2020-03-17T15:36:43.000Z","comments":false,"path":"categories/index.html","permalink":"http://figureai.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-23T03:58:59.265Z","updated":"2020-03-20T09:51:39.000Z","comments":true,"path":"links/index.html","permalink":"http://figureai.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-23T03:58:59.266Z","updated":"2020-03-17T14:35:23.000Z","comments":false,"path":"repository/index.html","permalink":"http://figureai.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-23T03:58:59.268Z","updated":"2020-03-17T14:35:23.000Z","comments":false,"path":"tags/index.html","permalink":"http://figureai.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js | 不常用函数集合","slug":"js | 不常用函数集合","date":"2020-05-12T06:07:14.000Z","updated":"2020-06-23T08:43:50.911Z","comments":true,"path":"2020/05/12/js | 不常用函数集合/","link":"","permalink":"http://figureai.github.io/2020/05/12/js%20|%20%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88/","excerpt":"","text":"数字年份转大写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function date2word(year&#x3D;&#39;2020&#39;,month&#x3D;&#39;10&#39;,day&#x3D;&#39;05&#39;) &#123; const dateWord &#x3D; &#123; &#39;0&#39;:&#39;零&#39;, &#39;1&#39;:&#39;一&#39;, &#39;2&#39;:&#39;二&#39;, &#39;3&#39;:&#39;三&#39;, &#39;4&#39;:&#39;四&#39;, &#39;5&#39;:&#39;五&#39;, &#39;6&#39;:&#39;六&#39;, &#39;7&#39;:&#39;七&#39;, &#39;8&#39;:&#39;八&#39;, &#39;9&#39;:&#39;九&#39;, &#39;10&#39;: &#39;十&#39; &#125; const monthWord &#x3D; &#123; &#39;1&#39;:&#39;正&#39;, &#39;2&#39;:&#39;二&#39;, &#39;3&#39;:&#39;三&#39;, &#39;4&#39;:&#39;四&#39;, &#39;5&#39;:&#39;五&#39;, &#39;6&#39;:&#39;六&#39;, &#39;7&#39;:&#39;七&#39;, &#39;8&#39;:&#39;八&#39;, &#39;9&#39;:&#39;九&#39;, &#39;10&#39;: &#39;十&#39; &#125; &#x2F;&#x2F; 转换年 const yearArr &#x3D; (year+&#39;&#39;).split(&#39;&#39;) let yearStr &#x3D; &#39;&#39; yearArr.forEach((value,index)&#x3D;&gt;&#123; yearStr +&#x3D; dateWord[value] &#125;) &#x2F;&#x2F; 转换月 let monthStr &#x3D; &#39;&#39; if((month*1) &gt; 10) &#123; monthStr &#x3D; &#39;十&#39;+dateWord[(month*1)%10+&#39;&#39;]+&#39;月&#39; &#125; else &#123; monthStr &#x3D; monthWord[month*1+&#39;&#39;] + &#39;月&#39; &#125; &#x2F;&#x2F; 转换日 let dayStr &#x3D; &#39;&#39; if((day*1)&gt;10) &#123; const dayDivide &#x3D; parseInt(day*1&#x2F;10) const dayRemain &#x3D; (day*1)%10 if(dayDivide &gt; 1) &#123; dayStr &#x3D; dateWord[dayDivide+&#39;&#39;] + &#39;十&#39; + dateWord[dayRemain+&#39;&#39;] &#125; else &#123; dayStr &#x3D; &#39;十&#39; + dateWord[dayRemain+&#39;&#39;] &#125; &#125; else &#123; dayStr &#x3D; &#39;初&#39; + dateWord[day*1+&#39;&#39;] &#125; return &#123;year:yearStr, month: monthStr, day: dayStr&#125;&#125;","categories":[],"tags":[]},{"title":"gitignore忽略规则简单说明","slug":"gitignore文件配置规则","date":"2020-05-09T09:05:04.000Z","updated":"2020-06-23T08:43:50.911Z","comments":true,"path":"2020/05/09/gitignore文件配置规则/","link":"","permalink":"http://figureai.github.io/2020/05/09/gitignore%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99/","excerpt":"","text":".gitignore忽略规则简单说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 表示此为注释,将被Git忽略*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外&#x2F;TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir&#x2F;TODObuild&#x2F; 表示忽略 build&#x2F;目录下的所有文件，过滤整个build文件夹；doc&#x2F;*.txt 表示会忽略doc&#x2F;notes.txt但不包括 doc&#x2F;server&#x2F;arch.txt bin&#x2F;: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件&#x2F;bin: 表示忽略根目录下的bin文件&#x2F;*.c: 表示忽略cat.c，不忽略 build&#x2F;cat.cdebug&#x2F;*.obj: 表示忽略debug&#x2F;io.obj，不忽略 debug&#x2F;common&#x2F;io.obj和tools&#x2F;debug&#x2F;io.obj**&#x2F;foo: 表示忽略&#x2F;foo,a&#x2F;foo,a&#x2F;b&#x2F;foo等a&#x2F;**&#x2F;b: 表示忽略a&#x2F;b, a&#x2F;x&#x2F;b,a&#x2F;x&#x2F;y&#x2F;b等!&#x2F;bin&#x2F;run.sh 表示不忽略bin目录下的run.sh文件*.log: 表示忽略所有 .log 文件config.php: 表示忽略当前路径的 config.php 文件 &#x2F;mtk&#x2F; 表示过滤整个文件夹*.zip 表示过滤所有.zip文件&#x2F;mtk&#x2F;do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!&#x2F;mtk&#x2F;one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理&#x2F;mtk&#x2F;目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：&#x2F;mtk&#x2F;*!&#x2F;mtk&#x2F;one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把&#x2F;mtk&#x2F;目录下除了one.txt以外的所有文件都写出来！注意上面的&#x2F;mtk&#x2F;*不能写为&#x2F;mtk&#x2F;，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1&#x2F;*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 &#x2F;fd1&#x2F; 目录，还是某个子目录 &#x2F;child&#x2F;fd1&#x2F; 目录，都会被忽略； &#x2F;fd1&#x2F;*说明：忽略根目录下的 &#x2F;fd1&#x2F; 目录的全部内容； &#x2F;*!.gitignore!&#x2F;fw&#x2F; &#x2F;fw&#x2F;*!&#x2F;fw&#x2F;bin&#x2F;!&#x2F;fw&#x2F;sf&#x2F;说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 &#x2F;fw&#x2F;bin&#x2F; 和 &#x2F;fw&#x2F;sf&#x2F; 目录；注意要先对bin&#x2F;的父目录使用!规则，使其不被排除。","categories":[],"tags":[]},{"title":"redux、react-redux、redux-thunk结合使用","slug":"redux、react-redux、redux-thunk结合使用","date":"2020-05-08T07:27:09.000Z","updated":"2020-06-23T08:43:50.912Z","comments":true,"path":"2020/05/08/redux、react-redux、redux-thunk结合使用/","link":"","permalink":"http://figureai.github.io/2020/05/08/redux%E3%80%81react-redux%E3%80%81redux-thunk%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简单介绍 redux redux是一个统一数据流状态管理的js库，本身使用与react、或者vue框架等无关。 react-redux 将redux应用到react上的库。 redux-thunk redux-thunk，redux 的一个中间件，可以实现在使用redux时发异步action。 什么时候需要使用redux 当你的应用有许多动态数据需要在不同的页面共享时，比如说当用户修改了账户昵称之后所有的相关页面都要更新昵称，面对这样的需求，如果不使用redux，则需要通过发送通知或者数据传递的方式来解决，而使用redux则可以大大简化操作。 redux 核心概念 Store Store 是 redux存放数据的地方，每个应用有且只有一个store，比如说修改昵称那个例子，昵称字段（假设为nickName）就需要存放在store中，其他用到的页面也是从store获取，当store中的nickName更新时，所有用到的页面或组件就会自动更新。 123456789import &#123;createStore&#125; from &#39;redux&#39;import rootReducers from &#39;.&#x2F;reducers&#x2F;index&#39;&#x2F;&#x2F; 创建一个storage const store &#x3D; createStore( rootReducers,)export default store Reducer reducer 是用来计算组成state的纯函数，每个reducer都会接收一个旧的state和action，并且返回一个新的state，需要注意的是，reducer是一个纯函数，固定的输入会得到固定输出，因此要避免在reducer中修改传入的参数，或者使用Date.now()、Math.random()。 1234567891011121314&#x2F;&#x2F; reducer 接收旧的state和新的action，返回新的stateconst counterReducer &#x3D; function(state&#x3D;&#123;count:1&#125;, action) &#123; switch(action.type) &#123; case &#39;COUNT_ADD&#39;: return &#123;...state, count: state.count+1&#125; case &#39;COUNT_REDUCE&#39;: return &#123;...state, count: state.count-1&#125; default: return state &#125;&#125;export default counterReducer Action 如果需要修改state中的数据，就需要通过分发action的方式来修改(Store.dispatch(action))，action包含type和payload字段，type定义了action的类型，payload则是此次action携带的数据。 12345678910111213141516171819&#x2F;&#x2F; action包含type和payload属性，reducer拿到action可以通过type进行相应的逻辑处理const addAction &#x3D; () &#x3D;&gt; &#123; return &#123; type: &#39;COUNTER_ADD&#39;, payload: &#123;&#125; &#125;&#125;const reduceAction &#x3D; () &#x3D;&gt;&#123; return &#123; type: &#39;COUNTER_REDUCE&#39;, payload: &#123;&#125; &#125;&#125;export &#123; addAction, reduceAction,&#125; redux 设计原则1231. 单一数据源：所有状态都保存在单一的store中2. state是只读的: 不能直接对store进行修改,只能通过新的store替换旧的store3. 使用纯函数来执行修改:reducer是只读的 react-redux 的作用 react-redux 能将redux那套逻辑应用在react框架上。 react-redux 核心 api Provider 通过Proveder可以把redux和react建立连接，将store传递到react项目中 12345678910111213import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import App from &#39;.&#x2F;App&#39;;import store from &#39;.&#x2F;store&#39;import &#123;Provider&#125; from &#39;react-redux&#39;ReactDOM.render( &#x2F;&#x2F; 通过Proveder把redux和react建立连接，将store传递到react项目中 &lt;Provider store&#x3D;&#123;store&#125;&gt; &lt;App &#x2F;&gt; &lt;&#x2F;Provider&gt;, document.getElementById(&#39;root&#39;)); connect 使用到store中数据的组件，需要先用connect修饰一遍 123456789101112131415161718&#x2F;&#x2F; 将 指定 的 store 合并到 props 传给组件const mapStateToProps &#x3D; (state, ownProps) &#x3D;&gt; &#123; return &#123; post: state.postReducer &#125;&#125; &#x2F;&#x2F; 将 指定的 dispatch 合并到 props 传给组件const mapDispatchToProps &#x3D; (dispatch, ownProps) &#x3D;&gt; &#123; return &#123; test: ()&#x3D;&gt;&#123; dispatch(loadPostsAction) &#125; &#125;&#125;&#x2F;&#x2F; HomeScreen经过connect 包装就可以使用 mapStateToProps，mapDispatchToProps 传递过去的数据了export default connect(mapStateToProps, mapDispatchToProps)(HomeScreen) redux-thunk 的作用 redux-thunk 是 redux的一个中间件，可以实现发异步action，因为有一些action携带的数据可能是由后台获取的，这时候就需要redux-thunk的协助了。 使用中间件 1234567891011121314import &#123;createStore, compose, applyMiddleware&#125; from &#39;redux&#39;import thunk from &#39;redux-thunk&#39;import rootReducers from &#39;.&#x2F;reducers&#x2F;index&#39;&#x2F;&#x2F; 创建一个storage storage 接收一个参数，reducerconst store &#x3D; createStore( rootReducers, compose( applyMiddleware(...[thunk,]), window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__(), ))export default store 发送异步action 12345678910111213import &#123;getPosts&#125; from &#39;..&#x2F;services&#x2F;post_api&#39;const loadPostsAction &#x3D; async (dispatch)&#x3D;&gt;&#123; const &#123;data&#125; &#x3D; await getPosts() dispatch(&#123; type: &#39;LOAD_POSTS&#39;, payload: data &#125;)&#125;export &#123; loadPostsAction&#125; 本文demo：redux使用示例 参考文章： Redux for react native 指南， Redux 入门教程（一）：基本用法","categories":[],"tags":[]},{"title":"ReactNative | bug 合集","slug":"ReactNative | bug 合集","date":"2020-03-29T05:27:39.000Z","updated":"2020-06-23T08:50:11.115Z","comments":true,"path":"2020/03/29/ReactNative | bug 合集/","link":"","permalink":"http://figureai.github.io/2020/03/29/ReactNative%20|%20bug%20%E5%90%88%E9%9B%86/","excerpt":"","text":"iOS xcode11 以上运行报错 Unknown argument type ‘attribute’ in method -[RCTAppState getCurrentAppState:error:]. Extend RCTConvert to support this type. // 解决方案一： 升级 RN 版本到 0.59.9 以上// 解决方案二： [project_folder]/node_modules/react-native/React/Base/RCTModuleMethod.mm 文件 第 91 行 return RCTReadString(input, &quot;__attribute__((unused))&quot;) ||后面添加RCTReadString(input, &quot;__attribute__((__unused__))&quot;) || 这一行 Xcode 编译项目时出现 config.h not found 原因：Xcode 文件引用出现问题解决方法：终端项目目录下执行以下两个指令node_modules/react-native/third-party/glog-0.3.4../../scripts/ios-configure-glog.sh 运行项目突然出现 Make sure you are running a packager server or have included a.bundle file in your application bundle 原因：vpn 开了全局代理，导致找不到项目的 jsbundle 包解决方法：关闭全局代理即可 终端运行 react-native run-ios 报 could not found iPhone6 原因：Xcode 版本过高，React-Native 版本过低解决方法： node_modules/react-native/local-cli/runIOS/findMatchingSimulator.js 文件123if (!version.startsWith(&#39;iOS&#39;) &amp;&amp; !version.startsWith(&#39;tvOS&#39;))改为if (!version.startsWith(&#39;com.apple.CoreSimulator.SimRuntime.iOS&#39;) &amp;&amp; !version.startsWith(&#39;com.apple.CoreSimulator.SimRuntime.tvOS&#39;)) React-Native 向 Web 页面注入代码，调用 window.postMessage() 出现 Setting onMessage on a WebView overrides existing values of window.postMessage, but a previous value was defined 原因：未知解决方法： 12345678910111213141516171819202122render() &#123;const patchPostMessageFunction &#x3D; function() &#123;var originalPostMessage &#x3D; window.postMessage; var patchedPostMessage &#x3D; function(message, targetOrigin, transfer) &#123; originalPostMessage(message, targetOrigin, transfer); &#125;; patchedPostMessage.toString &#x3D; function() &#123; return String(Object.hasOwnProperty).replace(&#39;hasOwnProperty&#39;, &#39;postMessage&#39;); &#125;; window.postMessage &#x3D; patchedPostMessage; &#x2F;&#x2F; 这里加入要注入到webview的逻辑 &#125;; const patchPostMessageJsCode &#x3D; &#39;(&#39; + String(patchPostMessageFunction) + &#39;)();&#39;; return ( &lt;WebView injectedJavaScript&#x3D;&#123;patchPostMessageJsCode&#125;&#x2F;&gt; ) &#125; iOS 无法输入中文的问题 1234567891011121314import React, &#123; Component &#125; from &#39;react&#39;import &#123; Platform, TextInput &#125; from &#39;react-native&#39;export default class LLTextInput extends Component &#123; shouldComponentUpdate (nextProps)&#123; return Platform.OS !&#x3D;&#x3D; &#39;ios&#39; || (this.props.value &#x3D;&#x3D;&#x3D; nextProps.value &amp;&amp; (nextProps.defaultValue &#x3D;&#x3D; undefined || nextProps.defaultValue &#x3D;&#x3D; &#39;&#39; )) || (this.props.defaultValue &#x3D;&#x3D;&#x3D; nextProps.defaultValue &amp;&amp; (nextProps.value &#x3D;&#x3D; undefined || nextProps.value &#x3D;&#x3D; &#39;&#39; )) &#125; render() &#123; return &lt;TextInput &#123;...this.props&#125; &#x2F;&gt; &#125;&#125; android 打包报错 Expected a name but was STRING at line 1 column 99 path $[0].apkInfo.versionName 把打包路径上的文件夹给删了，然后再打包就好了。比如我的 apk 是存储在 E:\\apk\\release 这个路径,然后我就把 release 文件夹给删除了，然后重新打包就好了。或者你也可以更换一下你的打包路径也可以哦。","categories":[],"tags":[]},{"title":"iOS | bug 合集","slug":"iOS | bug 合集","date":"2020-03-29T05:27:20.000Z","updated":"2020-04-02T05:32:06.175Z","comments":true,"path":"2020/03/29/iOS | bug 合集/","link":"","permalink":"http://figureai.github.io/2020/03/29/iOS%20|%20bug%20%E5%90%88%E9%9B%86/","excerpt":"","text":"","categories":[{"name":"iOS","slug":"iOS","permalink":"http://figureai.github.io/categories/iOS/"}],"tags":[]},{"title":"Android | bug 合集","slug":"Android | bug 合集","date":"2020-03-26T15:11:28.000Z","updated":"2020-04-03T05:31:43.142Z","comments":true,"path":"2020/03/26/Android | bug 合集/","link":"","permalink":"http://figureai.github.io/2020/03/26/Android%20|%20bug%20%E5%90%88%E9%9B%86/","excerpt":"","text":"打包时报错 You should manually set the same version via DependencyResolution 报错原因： 项目添加的第三方库依赖的版本不一致 1234567891011121314&#x2F;&#x2F; 解决方案一 ： 升级Android X&#x2F;&#x2F; 解决方案二 ： 项目级 gradle 文件下添加以下配置subprojects &#123; configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested &#x3D; details.requested if (requested.group &#x3D;&#x3D; &#39;com.android.support&#39;) &#123; if (!requested.name.startsWith(&quot;multidex&quot;)) &#123; details.useVersion &#39;25.4.0&#39; &#125; &#125; &#125; &#125;&#125; 打包时报错 Execution failed for task &#39;:app:lintVitalRelease&#39;. 12345678&#x2F;&#x2F; app&#x2F;build.gradleandroid &#123; ... &#x2F;&#x2F; 增加 lintOptions &#123; checkReleaseBuilds false &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://figureai.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://figureai.github.io/tags/Android/"}]},{"title":"js | 算法题","slug":"js | 算法题","date":"2020-03-24T07:46:10.000Z","updated":"2020-04-03T05:31:50.679Z","comments":true,"path":"2020/03/24/js | 算法题/","link":"","permalink":"http://figureai.github.io/2020/03/24/js%20|%20%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"注 本文示例代码使用 js 编写= 冒泡排序 比较相邻的两个元素，如果后一个比前一个大，交换位置 123456789101112const array &#x3D; [1,2, 0,421,2,33,4,344]for(let j &#x3D; 0; j &lt; array.length; j++) &#123; for(let k &#x3D; 0; k &lt; array.length; k++) &#123; let a &#x3D; array[j] let b &#x3D; array[k] if(b &lt; a) &#123; array[j] &#x3D; b array[k] &#x3D; a &#125; &#125;&#125;console.log(array) 数组去重 1234567891011const array &#x3D; [1,2,3,22,3,2,3,4]function deleteRepat(array) &#123; let dict &#x3D; &#123;&#125; for(let index &#x3D; 0; index &lt; array.length; index++) &#123; dict[array[index]] &#x3D; index &#125; return Object.keys(dict)&#125;console.log(Object.keys(dict)) 字符串转驼峰 border-bottom-color —-&gt; borderBottomColor 1234567891011121314151617function topUper(str) &#123; let result &#x3D; &#39;&#39; const splitArray &#x3D; str.split(&#39;-&#39;) for(let index &#x3D; 0; index &lt; splitArray.length; index++) &#123; let tempStr &#x3D; splitArray[index] if(index &#x3D;&#x3D; 0) &#123; result &#x3D; tempStr.toLowerCase() &#125; else &#123; result +&#x3D; tempStr.charAt(0).toUpperCase() + tempStr.substring(1) &#125; &#125; return result&#125;const str &#x3D; &quot;BBB-bottom-color&quot;console.log(topUper(str)) 查找字符串中出现次数最多的字符串 12345678910111213141516171819202122function getMaxCount(str) &#123; const splitArray &#x3D; str.split(&#39;&#39;) let result &#x3D; &#123;&#125; splitArray.forEach(target &#x3D;&gt; &#123; if(result[target] !&#x3D; undefined) &#123; result[target] +&#x3D; 1 &#125; else &#123; result[target] &#x3D; 0 &#125; &#125;); console.log(result) let maxKey &#x3D; Object.keys(result)[0] Object.keys(result).forEach(key &#x3D;&gt; &#123; if(result[key] &gt; result[maxKey]) &#123; maxKey &#x3D; key &#125; &#125;) return maxKey&#125;console.log(getMaxCount(&#39;aaaaabbeeeeeeeeeee&#39;)) 编写一个产生在 m、n 之间的随机整数的方法 12","categories":[{"name":"算法","slug":"算法","permalink":"http://figureai.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"js","slug":"js","permalink":"http://figureai.github.io/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://figureai.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js | 有趣的笔试题","slug":"js | 有趣的笔试题","date":"2020-03-24T06:27:41.000Z","updated":"2020-04-03T05:31:59.345Z","comments":true,"path":"2020/03/24/js | 有趣的笔试题/","link":"","permalink":"http://figureai.github.io/2020/03/24/js%20|%20%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/","excerpt":"","text":"请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象 123var url &#x3D; &quot;http:&#x2F;&#x2F;www.taobao.com&#x2F;index.php?key0&#x3D;0&amp;key1&#x3D;1&amp;key2&#x3D;2.....&quot;var obj &#x3D; parseQueryString(url);console.log(obj.key0) 答案 1234567891011121314function parseQueryString(url) &#123; const result &#x3D; url.split(&#39;?&#39;) if(result.length &lt; 2) &#123; return &#123;&#125; &#125; const queryStr &#x3D; result[1] const queryArray &#x3D; queryStr.split(&#39;&amp;&#39;) let dict &#x3D; &#123;&#125; queryArray.forEach(element &#x3D;&gt; &#123; const keyValues &#x3D; element.split(&#39;&#x3D;&#39;) dict[keyValues[0]] &#x3D; keyValues[1] &#125;); return dict&#125; 尝试实现注释部分的 Javascript 代码，可在其他任何地方添加更多代码（如不能实现，说明一下不能实现的原因）： 123456789var Obj &#x3D; function(msg)&#123; this.msg &#x3D; msg; this.shout &#x3D; function()&#123; alert(this.msg); &#125; this.waitAndShout &#x3D; function()&#123; &#x2F;&#x2F;隔五秒钟后执行上面的shout方法 &#125;&#125; 答案 123456789101112131415var Obj &#x3D; function(msg)&#123; this.msg &#x3D; msg; this.shout &#x3D; function()&#123; &#x2F;&#x2F; alert(this.msg); console.log(this.msg) &#125; this.waitAndShout &#x3D; function()&#123; &#x2F;&#x2F;隔五秒钟后执行上面的shout方法 setTimeout(()&#x3D;&gt;this.shout(), 5000) &#125; return this&#125;const obj &#x3D; Obj(&#39;hello&#39;)obj.waitAndShout() 请给 JavaScript 的 String 原生对象添加一个名为 trim 的原型方法，用于截取空白字符。要求： 12console.log(&quot; taobao&quot;.trim()); &#x2F;&#x2F; 输出 &quot;taobao&quot;console.log(&quot; taobao &quot;.trim()); &#x2F;&#x2F; 输出 &quot;taobao&quot; 答案 123String.prototype.trim &#x3D; function() &#123; return this.split(&#39; &#39;).join(&#39;&#39;)&#125; 请说明下面各种情况的执行结果，并注明产生对应结果的理由。 123456function doSomething() &#123; console.log(this);&#125;element.onclick &#x3D; doSomething &#x2F;&#x2F; 1. 点击element元素后。 element.onclick &#x3D; function() &#123;doSomething()&#125; &#x2F;&#x2F; 2. 点击element元素后。 doSomething() &#x2F;&#x2F; 3. 1231. 通过函数赋值方式，this直接指向element对象2. this 是写在doSomething()里边的，而this的指向又跟谁调用它有关，如果没有对象调用它，就是指向window3. this指向window","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://figureai.github.io/tags/js/"}]},{"title":"js | 的this指向问题","slug":"js | 关于js的this指针","date":"2020-03-23T03:17:10.000Z","updated":"2020-06-23T08:43:50.912Z","comments":true,"path":"2020/03/23/js | 关于js的this指针/","link":"","permalink":"http://figureai.github.io/2020/03/23/js%20|%20%E5%85%B3%E4%BA%8Ejs%E7%9A%84this%E6%8C%87%E9%92%88/","excerpt":"","text":"[toc] 关于 js 的 this 指向问题 一直以来对于 js 的 this 指针这一块理解都是比较模糊，也有查阅过相关资料，但是时间一长又会忘记，所以这篇文章单独记录一下 this 指针的指向问题，一方面加深记忆，一方面也方便自己查阅 要点 谁调用就指向谁，没人调用就指向window，简单来说函数的 this 和谁调用它有关。如果没有对象调用它，那么 this 就是指向 window（es5 环境下）函数的调用方式决定了 this 的指向，所以理解 this 的指向问题，最简单的方法就是通过分析 js 几种函数的调用模式。js 函数的调用模式有：函数调用模式、方法调用模式、构造函数调用模式、apply 和 call 调用模式、以及箭头函数 函数调用模式 函数被直接调用时，其实是作为属性挂载在全局对象下，所以这种模式在浏览器环境下 this 自然指向window 对象 方法调用模式 当函数被保存为一个对象的属性，通过对象 .或者 []调用时，称为方法调用模式，这种情况 this 被绑定在调用的对象上。 一层嵌套 1234567891011&#x2F;&#x2F;const dict &#x3D; &#123; name: &#39;dict&#39;, test: function() &#123; console.log(this.name) &#125;&#125;&#x2F;&#x2F; 打印 dictdict.test() 对象多重嵌套 这种情况下，不管是嵌套多少层，this 都会指向到调用他的对象上 12345678910111213const first &#x3D; &#123; name: &#39;first&#39;, second: &#123; name: &#39;second&#39;, test: function() &#123; console.log(this.name) &#125; &#125;&#125;&#x2F;&#x2F; 这里因为调用test方法是second对象，所以指向对象是secondfirst.second.test() 方法被赋值为一个新对象 这种情况下相当于回到函数调用模式 123456789101112131415const first &#x3D; &#123; name: &#39;first&#39;, second: &#123; name: &#39;second&#39;, test: function() &#123; console.log(this.name) &#125; &#125;&#125;name &#x3D; &#39;a&#39;&#x2F;&#x2F; 打印 a，这里因为a是挂载在全局对象下，所以this自然指向全局对象const a &#x3D; first.second.testa() 构造函数调用模式 如果函数在被 new 关键字创建为一个新的实例对象，那么这个函数就成为此对象的构造函数，如果构造函数不返回对象，this 就指向这个实例。 12345678&#x2F;&#x2F; 构造函数不返回对象，this指向实例function Fn() &#123; this.name &#x3D; &#39;hello&#39;&#125;const a &#x3D; new Fn()console.log(a.name) call 和 apply 调用模式 js 中的函数也是对象，所有函数都有两个方法 call 和 apply，这两个方法可以让我们构建一个参数数组传递给调用函数，同时也允许我们改变 this 的指向 1234567891011121314name &#x3D; &#39;window&#39;function getName() &#123; console.log(this.name)&#125;const a &#x3D; &#123; name: &#39;objA&#39;&#125;getName.apply(a) &#x2F;&#x2F; objAgetName.call(a) &#x2F;&#x2F; objAgetName.apply() &#x2F;&#x2F; windowgetName.call() &#x2F;&#x2F; window 注意 以下代码中是用 es6 的 class 定义的一个方法，这段代码在 es5 的环境下理论上应该是输出 ‘window’，但是实际运行 this 的指向会变成 undefined，猜测应该是 es6 的 class 关键字做了优化。 123456789101112131415161718192021222324252627&#x2F;&#x2F; es6name &#x3D; &#39;window&#39;class A &#123; constructor(name) &#123; this.name &#x3D; name &#125; getName() &#123; console.log(this.name) &#125;&#125;const a &#x3D; new A(&#39;objA&#39;)const test &#x3D; a.getName&#x2F;&#x2F; 报错test()&#x2F;&#x2F; es5name &#x3D; &#39;window&#39;function A(name) &#123; this.name &#x3D; name&#125;A.prototype.getName &#x3D; function() &#123; console.log(this.name)&#125;const a &#x3D; new A(&#39;objA&#39;)const test &#x3D; a.getName&#x2F;&#x2F; 打印windowtest()","categories":[{"name":"js","slug":"js","permalink":"http://figureai.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://figureai.github.io/tags/js/"}]},{"title":"提高github搜索精确度","slug":"GitHub | 高效搜索方式","date":"2020-03-21T00:24:58.000Z","updated":"2020-04-02T05:32:06.175Z","comments":true,"path":"2020/03/21/GitHub | 高效搜索方式/","link":"","permalink":"http://figureai.github.io/2020/03/21/GitHub%20|%20%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1234567891011121314151617181920212223&#x2F;&#x2F; xxx 代表搜索内容&#x2F;&#x2F; 在项目名进行精确搜索in:name xxx&#x2F;&#x2F; 搜索名字包含xxx，stars数量大于3000的项目in:name xxx stars:&gt;3000&#x2F;&#x2F; 搜索名字包含xxx，forks大于100的项目in:name xxx forks:&gt;100&#x2F;&#x2F; 搜索readme包含xxx的项目in:readme xxx&#x2F;&#x2F; 搜索描述包含xxx的项目in:description xxx&#x2F;&#x2F; 搜索xxx语言编写，名字包含xxx的项目in:name xxx language:xxx&#x2F;&#x2F; 搜索最后一次更细时间在2019年9月3日之后的项目xxx pushed:&gt;2019-09-03&#x2F;&#x2F;","categories":[{"name":"高效操作","slug":"高效操作","permalink":"http://figureai.github.io/categories/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"github","slug":"github","permalink":"http://figureai.github.io/tags/github/"},{"name":"效率","slug":"效率","permalink":"http://figureai.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"js | 正则表达式的基本使用","slug":"js | 正则表达式的基本使用","date":"2020-03-20T06:53:45.000Z","updated":"2020-04-03T05:32:05.689Z","comments":true,"path":"2020/03/20/js | 正则表达式的基本使用/","link":"","permalink":"http://figureai.github.io/2020/03/20/js%20|%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"正则表达式的使用 本文整理了一些常用的正则表达式匹配符，使用的示例代码为 js 编写，参考文章 正则表达式手册，MDN 文档-正则表达式 正则表达式规则类型 断言 表示一个匹配在某些条件发生 边界 表示行和单词的的开始和结尾，如：^ 匹配起始位置 ，$ 匹配结束位置 字符类别 区分不同类型的字符，如： \\D 匹配一个非数字字符，\\d 匹配一个数字字符 组合范围 表示表达式的分组和范围，如: [a-e0-4] 匹配a-e之间的字符以及0-4的数字 量词 表示匹配的字符或表达式的数量， 如： a{3,4} 匹配3个或4个字母a的字符 unicode 属性转义 基于 unicode 字符属性区分字符 常用的匹配规则 以下列的是常用匹配规则，完整的匹配规则可参考：正则表达式手册 123456789101112\\S : 匹配任意非空字符. : 匹配 \\n 之外的任何字符\\D : 匹配一个非数字字符，等价于[^0-9]\\d : 匹配个数字字符，等价于[0-9][0-9] : 匹配一个数字字符^ : 限定字符串的起始字符， 例如 ^a 限定匹配的字符串必须以 a 开头$ : 限定字符串的结束字符，例如 b$ 字符串必须以b结束\\w : 匹配包括下划线的任何单词或数字，等价于[A-Za-z0-9_]&#123;&#125; : 匹配指定次数，eg: a&#123;3,6&#125;，最低匹配三个字符a，最高匹配6个字符a() : 优先匹配括号中的内容+ : 至少匹配一次，等价于&#123;1,&#125; 全局匹配模式 全局匹配模式即在匹配到第一个字符串后，会继续往后检索，直到检索完所有内容 12345678const str &#x3D; &#39;123bb456bb789&#39;&#x2F;&#x2F; 输出 [ &#39;bb&#39;, &#39;bb&#39; ]console.log(str.match(&#x2F;bb&#x2F;g))const reg &#x3D; new RegExp(&quot;bb&quot;,&quot;g&quot;)&#x2F;&#x2F; 输出 [ &#39;bb&#39;, index: 3, input: &#39;123bb4567bb89&#39;, groups: undefined ]console.log(reg.exec(str)) js 字符串支持正则表达式的方法1234567891011121314151617const str &#x3D; &#39;123bb456d789&#39;&#x2F;&#x2F; search(reg): 检索与reg相匹配的值&#x2F;&#x2F; 输出： 3console.log(str.search(&#x2F;b&#123;2&#125;&#x2F;))&#x2F;&#x2F; match(reg): 找到一个或多个reg匹配的值&#x2F;&#x2F; 输出： [ &#39;456&#39;, index: 5, input: &#39;123bb456d789&#39;, groups: undefined ]console.log(str.match(&#x2F;[4-6]&#123;3&#125;&#x2F;))&#x2F;&#x2F; replace(reg, str): 替换与reg匹配的值为str的内容&#x2F;&#x2F; 输出： 123bb4561119console.log(str.replace(&#x2F;d[7-8]&#123;2&#125;&#x2F;, &#39;111&#39;))&#x2F;&#x2F; split(reg, number): 把字符依照reg匹配规则分割，并且返回一个number长度的数组&#x2F;&#x2F; 输出： [ &#39;123bb&#39;, &#39;d789&#39; ]console.log(str.split(&#x2F;456&#x2F;, 2)) js RegExp 对象123complie: 编译正则表达式。exec: 检索字符串中指定的值。返回找到的值，并确定其位置。test: 检索字符串中指定的值。返回 true 或 false。 常用的正则表达式12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 获取网络链接中的某个参数值&#x2F;&#x2F; gcGetUrlParam（url,params） &#123;&#x2F;&#x2F; var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + params + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);&#x2F;&#x2F; var result &#x3D; url.search.substr(1).match(reg);&#x2F;&#x2F; if (result &amp;&amp; result[2]) &#123;&#x2F;&#x2F; return result[2];&#x2F;&#x2F; &#125;&#x2F;&#x2F; return false;&#x2F;&#x2F; &#125;&#x2F;&#x2F; 裁剪xx到xx之间的任意内容&#x2F;&#x2F; let url &#x3D; https:&#x2F;&#x2F;www.v.qq.com&#x2F;?vid&#x3D;adfadsfds2243&amp;test&#x3D;true&#x2F;&#x2F; let reg &#x3D; &#x2F;vid&#x3D;(.*?)&amp;&#x2F;&#x2F;&#x2F; let vid &#x3D; url.match(reg)[1]&#x2F;&#x2F; 验证手机号码正则&#x2F;&#x2F; let reg &#x3D; &#x2F;^1([3-8])(\\d&#123;9&#125;)$&#x2F;&#x2F;&#x2F; let test &#x3D; &#39;13160694978&#39;&#x2F;&#x2F; let a &#x3D; reg.exec(test)&#x2F;&#x2F; console.log(a)&#x2F;&#x2F; 验证邮箱的正则&#x2F;&#x2F; let reg &#x3D; &#x2F;^((\\S|_|-)&#123;2,10&#125;)@(\\S&#123;2,6&#125;)(.com)$&#x2F;&#x2F;&#x2F; let test &#x3D; &#39;some_one@gmail.com&#39;&#x2F;&#x2F; let a &#x3D; reg.exec(test)&#x2F;&#x2F; console.log(a)&#x2F;&#x2F; 匹配任意重复字符&#x2F;&#x2F; var s &#x3D; &#39;aaabccc11fdsaa&#39;;&#x2F;&#x2F; var reg &#x3D; &#x2F;(.)\\1+&#x2F;g;&#x2F;&#x2F; console.log(s.match(reg)); &#x2F;&#x2F;[&quot;aaa&quot;, &quot;ccc&quot;, &quot;11&quot;]","categories":[{"name":"编程通用","slug":"编程通用","permalink":"http://figureai.github.io/categories/%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://figureai.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://figureai.github.io/categories/iOS/"},{"name":"Android","slug":"Android","permalink":"http://figureai.github.io/categories/Android/"},{"name":"算法","slug":"算法","permalink":"http://figureai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"js","slug":"js","permalink":"http://figureai.github.io/categories/js/"},{"name":"高效操作","slug":"高效操作","permalink":"http://figureai.github.io/categories/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9C/"},{"name":"编程通用","slug":"编程通用","permalink":"http://figureai.github.io/categories/%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://figureai.github.io/tags/Android/"},{"name":"js","slug":"js","permalink":"http://figureai.github.io/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://figureai.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"github","slug":"github","permalink":"http://figureai.github.io/tags/github/"},{"name":"效率","slug":"效率","permalink":"http://figureai.github.io/tags/%E6%95%88%E7%8E%87/"},{"name":"基础","slug":"基础","permalink":"http://figureai.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}